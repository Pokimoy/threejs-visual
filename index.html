<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaleidoscope_Ray</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera.position.z = 5;

            const uniforms = {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                mainColor: { value: new THREE.Vector3(0.5, 0.2, 0.5) }  
            };

            //glsl
            const customMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
                fragmentShader: `
                    precision highp float;
                    uniform float iTime;
                    uniform vec2 iResolution;
                    uniform vec3 mainColor;

                    float gTime = 0.;
                    const float REPEAT = 5.0;

                    mat2 rot(float a) {
                        float c = cos(a), s = sin(a);
                        return mat2(c, s, -s, c);
                    }

                    float sdBox(vec3 p, vec3 b) {
                        vec3 q = abs(p) - b;
                        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
                    }

                    float box(vec3 pos, float scale) {
                        pos *= scale;
                        float base = sdBox(pos, vec3(.4, .4, .3)) / 1.5;
                        pos.xy *= 5.;
                        pos.y -= 3.5;
                        pos.xy *= rot(.75);
                        return -base;
                    }

                    float box_set(vec3 pos, float iTime) {
                        vec3 pos_origin = pos;
                        pos.y += sin(gTime * 0.4) * 2.5;
                        pos.xy *= rot(.8);
                        float box1 = box(pos, 2. - abs(sin(gTime * 0.4)) * 1.5);
                        pos = pos_origin;
                        pos.y -= sin(gTime * 0.4) * 2.5;
                        pos.xy *= rot(.8);
                        float box2 = box(pos, 2. - abs(sin(gTime * 0.4)) * 1.5);
                        pos = pos_origin;
                        pos.x += sin(gTime * 0.4) * 2.5;
                        pos.xy *= rot(.8);
                        float box3 = box(pos, 2. - abs(sin(gTime * 0.4)) * 1.5);
                        pos = pos_origin;
                        pos.x -= sin(gTime * 0.4) * 2.5;
                        pos.xy *= rot(.8);
                        float box4 = box(pos, 2. - abs(sin(gTime * 0.4)) * 1.5);
                        pos = pos_origin;
                        pos.xy *= rot(.8);
                        float box5 = box(pos, .5) * 6.;
                        pos = pos_origin;
                        float box6 = box(pos, .5) * 6.;
                        return max(max(max(max(max(box1, box2), box3), box4), box5), box6);
                    }

                    float map(vec3 pos, float iTime) {
                        vec3 pos_origin = pos;
                        float box_set1 = box_set(pos, iTime);
                        return box_set1;
                    }

                    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                        vec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);
                        vec3 ro = vec3(0., -0.2, iTime * 4.);
                        vec3 ray = normalize(vec3(p, 1.5));
                        ray.xy = ray.xy * rot(sin(iTime * .03) * 5.);
                        ray.yz = ray.yz * rot(sin(iTime * .05) * .2);
                        float t = 0.1;
                        vec3 col = vec3(0.);
                        float ac = 0.0;

                        for (int i = 0; i < 99; i++) {
                            vec3 pos = ro + ray * t;
                            pos = mod(pos - 2., 4.) - 2.;
                            gTime = iTime - float(i) * 0.01;
                            
                            float d = map(pos, iTime);
                            d = max(abs(d), 0.01);
                            ac += exp(-d * 23.);
                            t += d * 0.55;
                        }

                        col = mainColor * ac * 0.02; 
                        col += vec3(0., 0.2 * abs(sin(iTime)), 0.5 + sin(iTime) * 0.2);
                        fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * sin(iTime)));
                    }

                    void main() {
                        mainImage(gl_FragColor, gl_FragCoord.xy);
                    }
                `
            });

            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const plane = new THREE.Mesh(planeGeometry, customMaterial);
            scene.add(plane);

            function animate(time) {
                requestAnimationFrame(animate);
                customMaterial.uniforms.iTime.value = time * 0.001;
                renderer.render(scene, camera);
            }

            // GUI
            const gui = new dat.GUI();
            const colorController = gui.addColor({ mainColor: '#ff69b4' }, 'mainColor');
            colorController.onChange(function(value) {
                const color = new THREE.Color(value);
                uniforms.mainColor.value = new THREE.Vector3(color.r, color.g, color.b);
            });

            function animate(time) {
                requestAnimationFrame(animate);
                customMaterial.uniforms.iTime.value = time * 0.001;
                renderer.render(scene, camera);
            }
            animate();
        });
    </script>
</body>
</html>



